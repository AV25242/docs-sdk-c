= Preempting errors from bad servers
:page-topic-type: concept

[abstract]
If a server is known to be down by the application, the application may utilize some of the library's APIs to avoid sending keys mapped to that server.

In Couchbase architecture, keys are mapped to [vBuckets], which in turn are mapped to cluster nodes.
When an operation is scheduled for a given key, the key is placed in a queue to be sent to a specific server.
If you know that a certain server is down or unavailable, you can avoid scheduling the operation and fail the request immediately by determining if the key's destination server is indeed a failed server.

In the C SDK the following steps should be used to determine the target host of a given key:

. Get the vBucket configuration object (via [.api]`lcb_cntl()`)
. Map the key to a server index (via [.api]`lcbvb_map_key()`)
. Get the `host:port` of the data node hosting the given key (via [.api]`lcb_get_node()` or [.api]`lcbvb_get_hostport()`)
. Strip the `:port` from the string to yield the hostname of the target server.

The following snippet shows how to do this in a single function (in C++)

[source,cpp]
----
    std::string hostForKey(lcb_t instance, const void *key, size_t nkey) {
        lcbvb_CONFIG *vbc;
        lcb_cntl(instance, LCB_CNTL_GET, LCB_CNTL_VBCONFIG, &vbc);
        int vbid, server_index;
        lcbvb_map_key(vbc, key, nkey, &vbid, &server_index);

        if (server_index < 0) {
            return ""; // We want to trigger a config refresh
        }

        // Find the server:
        const char *server = lcb_get_node(instance, LCB_NODE_DATA, server_index);
        const char *endp = strchr(server, ':');
        std::string host(server, endp);
        return host;
    }
----
